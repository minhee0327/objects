## 의존성 관리하기
### 의존성 이해하기
* 실행 시점에 의존 대상 객체 필요, 구현 시점에 의존 대상 객체가 변경이 의존하는 객체에 영향을 미치는 것
* 구현 시점에 객체 의존성이 영향을 미치는 것을 의존성 전이 라고 한다. 캡슐화가 잘 되어 있으면 의존성 전이가 되지 않을 수 있다.
* 협력 객체의 구체적인 클래스를 알고 있으면 강결합이 될 가능성이 높고 결합도가 높은 기능은 재사용하기 어렵다.
  * 협력 객체간의 최소한의 기능 혹은 구현(컨텍스트)만 알게 한다.
  * 인터페이스
* 구현 시점에 구체적인 클래스를 알아야 하는 컴파일타임 의존성을 실행 시점에 의존 객체를 결정하는 런타임 의존성으로 교체
  * 생성자, setter, 메서드 인자 방식으로 런타임에 의존관계를 맺게 할 수 있다.
### 유연한 설계
* 결합도를 낮추고 응집도를 높이는 방법
* 구체적인 클래스에 의존하는 것이 아닌 추상화에 의존하도록 설계
* 인터페이스는 단순 행위를 정의하는 것 뿐만 아닌 협력 관계 사이에 최소한의 컨텍스트만 표시하게 하여 결합도를 낮추게 한다.
  * 컨텍스트 확장(새로운 기능 추가)시에도 기존 기능 수정이 아닌 새로운 구현 클래스를 생성하여 의존성 전이의 가능성을 낮출 수 있다.
* 작은 객체들의 행동을 조합하여 새로운 행동을 이끌어 내는 설계
  * 객체들이 무슨 행동을 하는지를 표현
    * 캡슐화, 추상화

## 유연한 설계
### 개방-폐쇄 원칙
* 확장에 대해 열려있고 수정에 대해 닫혀있어야 한다.
  * 변경에 맞는 새로운 동작을 추가하여 기능 확장
  * 기존 코드를 수정하지 않아도 변경에 대응
* 추상화에 의존하도록 구현을 고정시키고(컴파일 타임 의존성) 동작하는 시점에 구체적인 객체들의 협력으로 동작(런타임 의존성)
### 생성 사용 분리
* 협력 객체의 생성하는 곳과 사용하는 곳을 분리
* 생성의 책임만 갖는 factory 객체, 도메인과 무관한 객체에 책임 할당
### 의존성 주입
* 외부의 독립적인 객체가 인스턴스를 생성 후 전달하여 의존성을 해결하는 방법
* 생성자, setter, 메서드 인자 방식
* Service Locator 패턴
  * 협력 객체의 생성을 별도의 클래스에서 생성하여 주입
  * 생성자 주입과 달리 주입하는 행위가 보이지 않아 의존성이 감춰진다.
### 의존성 역전 원칙
* 상위 수준 클래스는 하위 수준 클래스에 의존하지 않고 추상화에 의존하게 한다.
* 구체적인 사항은 추상화에 의존해야 한다.
### 유연성에 대한 조언
* 유연성은 항상 복잡성을 수반한다. 유연하지 않는 설계는 단순하고 명확하다.
* 불필요하게 복잡한 것 보다 단순하고 명확한 설계가 더 좋을 수 있다.
* 도메인의 적절한 책임을 갖는 객체들이 협력하는 설계


