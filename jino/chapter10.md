# Week 6 - chapter 10 상속과 코드 재사용

## 📌 학습 내용 요약
- 재사용 관점에서 상속이란 클래스 안에 정의된 인스턴스 변수와 메서드를 자동으로 새로운 클래스에 추가하는 구현 기법이다.
- 합성: 새로운 클래스의 인스턴스 안에 기존 클래스의 인스턴스를 포함시키는 방법으로 흔히 합성이라고 부른다.
- DRY 원칙
  - 중복 코드는 변경을 방해한다.
  - 반복하지 마라
- 중복과 변경
- 상속은 결합도를 높인다. 상속이 초래하는 부모 클래스와 자식 클래스 사이의 강한 결합이 코드를 수정하기 어렵게 만든다.
- 기존 java 에서도 발생한 상속에 대한 문제
  - stack, properties
- 상속받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨트릴 수 있다.
- 자식 클래스가 부모 클래스의 메서드를 오버라이딩할 경우 부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될수 있다.
- 상속은 코드 재사용을 위해 캡슐화를 희생한다.
- 결합도란 다른 대상에 대해 알고 있는 지식의 양
- 상속은 기본적으로 부모 클래스의 구현을 재사용한다는 기본 전제를 따르기 때문에 자식 클래스가 부모 클래스의 내부에 대해 속속들이 알도록 강요한다.
- 클래스를 상속하면 결합도로 인해 자식 클래스와 부모 클래스의 구현을 영원히 변경하지 않거나, 자식 클래스와 부모 클래스를 동시에 변경하거나 둘 중 하나를 선택할 수 밖에 없다.
- 방법은 추상화
  - 부모 클래스와 자식 클래스 모두 추상화에 의존하도록 수정한다.
  - 중복 코드를 부모 클래스로 올려라
  - calculateCallFee 를 시그니처만 부모클래스리 이동 시키고, 추상메서드로 선언하고, 자식 클래스에서 오버라이딩 할수있도록 protected 로 선언
- 객체 생성 로직이 변경됐을 때 영향을 받는 부분을 최소화 하기 위해 노력해야한다.
- 정말로 필요한 경우에만 상속을 사용하자.

## 💡 느낀 점
- 상속을 쓰지 않을 이유에 대해 설명하는 챕터
- 

## ❓ 궁금한 점
- 중복 코드를 없애기 위해, 서로 다른 목적을 가졌지만 궁극적으로 같은 동작을 하는 경우 중복이 벌어지게 하나로 합쳤더니,
나중에 그 중복 코드를 사용하는 로직 중 다른 하나의 로직 때문에 변경이 필요할 경우, 
그 중복 코드를 하나 더 만드는게 맞는걸까? 아니면 내부적으로 플래그를 추가해서 처리?
 - findProduct: dynamic query 부분으로 처리 (QueryParam 으로 처리하니까 필드 추가는 없으나, 코드 내부적으로 어느 곳에서 요청하냐에 따라 다르게 메서드가 동작)

## 🔗 참고 링크
- 
