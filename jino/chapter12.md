# Week 7 - chapter 12 다형성

## 📌 학습 내용 요약
- 코드 재사용을 목적으로 상속을 사용하면 변경하기 어렵고 유연하지 못한 설계에 이를 '확률'이 높아진다
- 상속의 목적은 재사용이 아닌, 타입 계층을 구조화하기 위해 사용해야 한다.
- 클라이언트 관점에서 인스턴스들을 동일하게 행동하는 그룹으로 묶기 위해서 인가를 잘 따져 볼 것
- 오버로딩 다형성 : 하나의 클래스 안에 동일한 이름의 메서드가 존제하는 경우
- 강제 다형성 : 언어가 지원하는 자동적인 타입 변환, 사용자가 직접 구현한 타입 변환을 이용해 동일한 연산자를 다양한 타입에 사용 할 수 있는 방식
- 매개변수 다형성 : 제네릭 T
- 포함 다형성 : 메시지가 동일하더라도 수신한 객체의 타입에 따라 실제로 수행되는 행동이 달라지는 것 (서브타입 다형성) - 보통 다형성이란 이것을 이야기함
- 상속의 진정한 목적은 코드 재사용이 아닌, 다형성을 위한 서브타입 계층을 구축하는 것
- 데이터 관점, 행동 관점, 단순히 보면 상속이란 부모 클래스에서 정의한 데이터와 행동을 자식 클래스에게 자동적으로 공유할 수 있는 매커니즘 처럼 보일 것이지만
프로그램을 구성하는 개념들을 기반으로 다형성을 가능하게 하는 타입 계층을 구축하기 위한 것
  - 업캐스팅/동적 메서드 탐색/동적 바인딩/self 참조/super 참조
- 부모클래스의 모든 퍼블릭 메서드는 자식 클래스의 퍼블릭 인터페이스에 포함된다
- 런타임에 시스템이 자식 클래스에 정의되지 않은 메서드가 있을 경우 이 메서드를 부모 클래스 안에서 탐색
- 코드 안에서 선언된 참조 타입과 무관하게 실제로 메시지를 수신하는 객체의 타입에 따라 실행되는 메서드가 달라질 수 있는 것은 업캐스팅과 동적바인딩이라는 매커니즘이 작용하기 때문
  - 업캐스팅 : 부모클래스 타입으로 선언된 변수에 자식 클래스의 인스턴스를 할당
  - 동적 바인딩 : 선언된 변수의 타입이 아니라 메시지를 수신하는 객체의 타입에 따라 실행되는 메서드가 결정
  - 다운캐스팅: 부모 클래스의 인스턴스를 자식 클래스 타입으로 변환하기 위해서는 명시적인 타입 캐스팅이 필요
- 함수 호출과, 메시지 전송 : 프로그램 안에 작성된 함수 호출 구문과 실제로 실행되는 코드를 연결하는 언어적인 매커니즘이 다리그 때문에, 차이가 크다
- 실행되는 메서드 선택 규칙
  - 메시지를 수신한 객체는 먼저 자신을 생성한 클래스에 적합한 메서드가 존재하는지 검사
  - 메서드를 찾지 못했다면 부모 클래스에서 메서드 탐색을 계속, 상속 계층을 따라 올라가며 계속
  - 최상위 클래스에 이르렀지만 메서드를 발견하지 못한 경우 예외 발생, 탐색 중단
- self 참조(this): 시스템은 class 포인터, parent 포인터와 함께 self 참조를 조합해서 메서드를 탐색
- 메서드 오버라이딩이 부모 클래스의 메서드를 감추는 것처럼 보이는 이유는, 먼저 자신을 생성한 클래스에 적합한 메서드가 존재하는지 검사하기 때문이다.
- 하나의 클래스 안에서만 메서드 오버로딩이 있는것이 아니라, 상속 관계에서도 메서드 오버로딩이 있다.
- self 참조가 동적인 문맥을 결정한다.
  - 자신에게 다시 메시지를 전송하는 self 전송 (현재 클래스의 메서드를 호출 하는게 아닌 현재 객체에게 메시지를 전송) ***
  - 부모의 메서드 안에서 this 메서드를 호출할 때, self 가 가리키는 객체가 호출 되기 때문에 메서드 오버라이딩 된 self 참조가 가리키는 객체가 호출 된다
- super 참조: 부모 클래스의 구현을 재사용해야 하는 경우, super 참조라는 내부 변수를 제공
- 더 상위에 위치한 조상 클래스의 메서드일수도 있다.
  - 상위 부모 > 부모 > 자식 관계일 때, 부모 클래스에 해당하는 super.method 가 없다면 더 상위의 부모 클래스에서 메서드를 탐색한다.
  - 지금 이 클래스의 부모 클래스에서 부터 메서드 탐색을 시작하세요! 라는 뜻!
- 자식 클래스에서 부모 클래스로 self 참조를 전달 하는 메커니즘으로 상속을 바라보는 것
- 위임: 자신이 수신한 메시지를 다른 객체에게 동일하게 전달해서 처리를 요청하는것을 위임이라고 한다.
  - 포워딩과 위임: 인자로 self 참조를 전달하지 않으면 포워딩, self 참조를 전달하면 위임
- 

## 💡 느낀 점
- 

## ❓ 궁금한 점
- p 415 맨 아랫줄, 부모 클래스에 정의된 모든 메서드를 자식 클래스에서 오버라이딩 하는거 아닌가? 오버로딩 오타인가.
- 다운 캐스팅 사용 하는 법? 활용하는 곳?
  - Parent parent = new Child(); 로 사용할 때 결국 parent의 메서드만 사용 가능한데 이럴 때 쓰는건가?
    - if(parent instance of Child) Child child = (Child) parent; 
  - List list = new ArrayList(); 일 때 ArrayList 의 메서드를 쓰고 싶을 때??

  

## 🔗 참고 링크
- 
