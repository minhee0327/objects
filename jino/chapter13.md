# Week 7 - chapter 13 서브클래싱과 서브타이핑

## 📌 학습 내용 요약
- 상속은 두가지 용도로 사용된다
  - 타입 계층 구현: 부모클래스-일반화, 자식클래스-특수화
  - 코드 재사용: 부모 클래스와 자식 클래스가 강하게 결합되기 때문에 변경이 어려운 코드를 얻게 될 확률이 높음
- 상속은 서브타입 다형성과 동적 메서드 탐색에 밀접하게 연관되어있다.
- 타입
  - 개념 관점: 우리가 인지하는 세상의 사물의 종류
  - 우리가 인식하는 객체들에 적용하는 개념이나 아이디어를 가리켜 타입이라고 부른다.
  - 그 대상을 타입의 인스턴스라고 부른다. 이것을 객체라고 부른다.
    - 심볼: 타입에 이름을 붙인 것
    - 내연: 객체들이 공유하는 송석과 행동의 집합이 내연을 구성
    - 외연: 타입에 속하는 객체들의 집합
  - 프로그래밍 언어 관점의 타입: 객체의 타입으로 문맥을 결정한다.
  - 객체지향 패러다임 관점의 타입
    - 동일한 오퍼레이션을 적용할 수 있는 인스턴스들의 집합
    - 객체의 퍼블릭 인터페이스가 객체의 타입을 결정한다. 따라서 동일한 퍼블릭 인터페이스를 제공하는 객체들은 동일한 타입으로 분류된다.
  - 상태가 다르더라도 행동(퍼블릭 인터페이스를)을 공유한다면 동일한 타입이다.
- 슈퍼타입, 서브타입
- 일반화 : 다른타입을 완전히 포함하거나, 내포하는 타입을 식별하는 행위 또는 그 행위의 결과를 가리킨다
- 특수화 : 다른 타입 안에 전체적으로 포함되거나 완전히 내포되는 타입을 식별하는 행위 또는 그 행의의 결과를 가리킨다.
- 서브타입의 인스턴스는 슈퍼타입의 인스턴스로 간주될 수 있다.
- 상속을 이용해 타입 계층을 구현한다는 것은 부모 클래스가 슈퍼타입의 역할을, 자식 클래스가 서브타입의 역할을 수행하도록 클래스아이의 관계를 정의한다는 것을 의미
  - "IS-A" : 자식클래스는 부모클래스다 라고 말해도 이상하지 않다면 상속을 사용할 후보로 간주할 수 있다.
  - 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가 / 클라이언트는 그 차이를 몰라야 한다.
  - child is-a parent / A is-a B, 타입 A는 타입 B 이다.
  - ? 펭귄은 새다, 새는 날 수 있다. 고로 펭귄은 날수 있다? 노노 틀림
  - 어휘적인 정의가 아니라 기대되는 행동에 따라 타입 계층을 구성해야 한다.
- 펭귄의 fly 메서드를 고치더라도 클라이언트 입장의 기대를 만족시킬 수 없기 때문에 올바른 설계라고 할 수 없다.
- 클라이언트의 기대에 맞게 상속 계층을 분리한다.
  - 새 / 날수있는새 / 날수없는새 > 펭귄
- 인터페이스 분리 원칙
- 자연어에 현혹되지 말고 요구사항 속에서 클라이언트가 기대하는 행동에 집중할 것
- 리스코프 치환 원칙
  - 서브타입은 그것의 기반 타입에 대해 대체 가능해야 한다. 차이점을 인식하지 못한 채 기반 클래스의 인터페이스를 통해 서브클래스를 사용할 수 있어야 한다.
  - 행동 호환성을 유지하여 부모 클래스를 대체할 수 있도록 구현된 상속 관계만 서브타임핑이라고 불릴 수 있다.
- 정사각혁은 직사각형이다 하나만 믿고 하다간 안된다는 이야기임
- 강한 사전조건, 약한 사후조건을 서브타입에 할 수 없다...?

## 💡 느낀 점
- is-a 만 중요하다고 생각했는데, 행동 관점이 일치해야 한다는것이 더 중요하다는 것을 알았다.
- 직사각형과 정사각형에 대해 누가봐도 상속관계로 가능할 것 같지만, 클라이언트와의 협력 관계속으로 모델을 밀어넣는 순간 지금까지 올바르다고 생각했던 서브타입이 올바르지 않다는 사실을 깨닫기 된다.
- 즉 클라이언트 관점에서 is-a 여야한다는 것이 중요.

## ❓ 궁금한 점
- 사전 조건 사후 조건에서, 그렇다면 상속에서의 서브타입을 위해서는 조건을 강화하거나 약화하는 것 까지 고려해서 작성해야 한다는 뜻...? 그렇지 않으면 리스코프 치환원칙 위배???

  

## 🔗 참고 링크
- 
