# Week 3 - chapter 4 설계 품질과 트레이드 오프

## 📌 학습 내용 요약
- 책임 주도 설계, 제일 중요한건 책임
- 객체지향이란: 올바른 객체에게 올바른 책임을 할당하면서, 낮은 결합도와, 높은 응집도를 가진 구조를 창조하는 활동
- 설계는 변경을 위해 존재하고, 변경은 비용이 발생한다. 훌륭한 설계란 합리적인 비용안에서 변경을 수용할 수 있는 구조를 만드는 것
- 쉬운 변경은 응집도가 높고, 서로 느슨하게 결합돼 있어야 가능하다
- 캡슐화
  - 객체지향에서 가장 중요한 원리, 불안정한 구현 세부사항을 안정적인 인터페이스 뒤로
- 접근자와 수정자 (getter, setter)에 과도하게 의존하는 설계 방식을 추측에 의한 설계 전략이라고 부르며, 객체가 사용 될 협력을 고려하지 않고,
객체가 다양한 상황에서 사용 될 수 있을 것이라는 막연한 추측을 기반으로 설계를 진행하며, 캡슐화의 원칙을 위반하는 변경에 취약한 설계를 얻게 된다.
- 단일 책임 원칙 : 책임 == 변경의 이유
- 스스로 자신의 데이터를 책임지는 객체
  - 이 객체가 어떤 데이터를 포함해야 하는가
     - 이 객체가 데이터에 대해 수행해야 하는 오퍼레이션은 무엇인가.
 - 파급효과
   - 내부 구현의 변경이 외부로 퍼져나가는 파급효과는 캡슐화가 부족하다는 증거
   - 자기 자신을 스스로 처리한다는 점에서 개선되었지만 내부의 구현을 캡슐화하는 데는 실패한 것
   - 메서드명 또는 필드 종류로 내부 구현을 인터페이스에 노출시킨다.
   - DiscountCondition에 의존하는 movie가 변경된다는 것

## 💡 느낀 점
- 데이터 중심 설계가 이렇게 잘못된것인가.
- 나는 지금 데이터 중심 설계를 하고 있는 것인가, 객체 중심 설계를 하고 있는 것인가 판단해봐야 겠다.
- 무조건 한쪽이 옳은건 아니겠지만, 내가 무의식적으로 행하고 있는 설계 방법에 대한 고찰 필요


## ❓ 궁금한 점
- 메서드명 또는 필드 종류로 내부 구현을 인터페이스에 노출시킨다.
  - stream api 의 map 에서 보통 많이 사용하는 ClassName::getParam 이런 경우나, filter(ClassName::isActive) 같은 경우는 괜찮은걸까?

- DiscountCondition 의존성 문제: Movie가 DiscountCondition 인터페이스에 의존하는 것 자체는 문제가 아닐 수 있습니다. 문제는 Movie가 DiscountCondition의 구체적인 구현 방식이나 내부 데이터 구조를 알아야 할 때 발생합니다. 인터페이스를 통해 협력하되, 구현 세부사항은 캡슐화하는 것이 중요합니다.
  - 핵심: Movie가 DiscountCondition에게 "할인 조건을 만족하는가?" (isSatisfiedBy) 라고 묻는 것을 넘어, "당신은 어떤 종류의 할인 조건인가?" 또는 "당신이 가진 특정 데이터는 무엇인가?"
  - 예시: instanceof 나 캐스팅을 통해 구체적인 구현 클래스 타입을 확인하고 분기 처리한다.
인터페이스에 구현 클래스의 내부 데이터나 종류를 유추할 수 있는 메서드(getType, getSequence 등)가 있고, 이를 이용해 분기 처리한다.


## 🔗 참고 링크
-
