# Week 5 - chapter 9 유연한 설계

## 📌 학습 내용 요약
- 개방-폐쇄 원칙, ocp
  - 확장에 열려 있고, 수정에 닫혀있다.
  - 컴파일 의존성을 고정시키고 런타임 의존성을 변경
  - 핵심, 추상화에 의존한다.
- 생성 사용 분리
  - 결합도가 높아질수록 개방-폐쇄 원칙을 따르는 구조 설계가 어려워진다.
  - 객체 생성과 객체 사용이라는 이질적인 목적을 가진 코드가 공존하지 않는 것이 중요하다.
  - 팩토리 - 생성 책임
- 시스템을 객체로 분해하는 데는 표현적 분해, 행위적 분해
  - 표현적 분해 : 도메인에 존재하는 사물 또는 개념을 표현하는 객체들을 이용해 시스템을 분해
  - 행위적 분해 : 어떤 행동을 추가하려고 하는데 이 행동을 책임질 마땅한 도메인 개념이 존재하지 않는다면, 순수한 가공물을 추가하고 이 객체에게 책임을 할당하라.
- 시스템에서 인공적으로 창조한 객체들이 도메인 개념을 반영하는 객체들보다 오히려 더 많은 비중을 차지하는 것이 일반적
- 도메인의 본질적인 개념을 표현하는 추상화를 이용해 애플리케이션을 구축하기 시작
  > 도메인 개념이 만족스럽지 못하다면 주저하지 말고 인공적인 객체를 창조
  > 객체지향이 실세계를 모방해야 한다는 헛된 주장에 현혹될 필요가 없다
  > 구조라는 제약 안에서 실용적인 창조성을 발휘할 수 있는 능력은 훌륭한 설계자가 갖춰야 할 기본적인 자질이다.
- 순수한 가공물 : 적절한 대안이 없을 때 사람들이 창조적인 무언가를 만들어낸다는 것을 의미하는 관용적 표현
- 의존성 주입
  - 외부에서 의존성의 대상을 해결한 후 이를 사용하는 객체 쪽으로 주입하기 때문
- Service Locator 패턴
  - 의존성을 감춘다
- 의존성 역전의 원칙
  - 하위 수준의 클래스가 상위 수준의 클래스에 의존하여 하위 수준의 변경에 의해 상위 수준 클래스가 영향을 받게 되는 것
  - 추상화를 통해 추상화에 의존하도록 수정하면, 하위 수준 클래스의 변경으로 인해 상위 수준의 클래스가 영향을 받는것을 방지한다.
  - 상위 클래스 및 하위 클래스 모두 추상 클래스에 의존한다.
- 유연한 설계는 유연성이 필요할 때만 옳다
  - 런타임 의존성과 컴파일 타임 의존성의 차이를 인식하고 동이ㅏㄹ한 컴파일 타임 의존성으로 부터 다양한 런타임 의존성을 만들 수 있는 코드 구조를 가지는 설계를 의미
  - 하지만 항상 좋은 것은 아니다.
  - 설계의 미덕은 단순함과 명확함으로부터 나온다.
  - 유연한 설계 = 복잡한 설계
  - 정말 유연성이 필요할까
  - 

## 💡 느낀 점
- 역전 : 상위 수준의 모듈이 하위 수준의 모듈에 의존하고, 정책이 구체적인 것에 의존하는 경향이 있지만, 일반적으로 만들어진 의존성 구조에 대해 역전 된 것,
- 객체의 역할과 책임이 자리를 잡기 전에 너무 성급하게 객체 생성에 집중하지 말 것
## ❓ 궁금한 점
- 

## 🔗 참고 링크
- 
