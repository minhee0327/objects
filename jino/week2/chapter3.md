# Week 2 - chapter 3 역할, 책임, 협력

## 📌 학습 내용 요약
- 애플리케이션의 기능을 구현하기 위해 어떤 협력이 필요하고 협력을 위해 어떤 역할과 책임이 필요한지를 고민하지 않은 채 너무 이른 시기에 구현에 초점을 맞추는 것은 변경하기 어렵고, 유연하지 못한 코드를 낳는 원인이 된다.
- 협력: 객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용
- 책임: 객체가 협력에 참여하기 위해 수행하는 로직
- 역할: 객체들이 협력 안에서 수행하는 책임
- 객체를 자율적으로 만들 것, 내부 구현을 캡슐화 하는 것, 메시지를 통해 요청 하는 것
- 객체의 책임을 크게, 하는 것, 아는 것으로 세분화 할 수 있다.
- 책임할당
  - 자율적인 객체를 만드는 가장 기본적인 방법은 책임을 수행하는 데 필요한 정보를 가장 잘 알고 있는 전문가에게 그 책임을 할당 하는 것
  - 정보 전문가 패턴
  - 객체가 책임을 수행하게 하는 유일 방법은 메시지 전송, 책임을 할당한다는 것은 어떻게 보면 메시지의 이름을 결정하는 것과 같다.
  - 메시지가 객체를 결정하는 것
- 객체지향 패러다임에 갓 입문한 사람들이 가장 쉽게 빠지는 실수
  - 객체의 행동이 아니라 상태에 초점을 맞추는 것
  - 객체에 필요한 상태가 무엇인지를 결정하고, 그 후에 상태에 필요한 행동을 결정한다
  - 이런 방식은 객체의 내부 구현이 객체의 퍼블릭 인터페이스에 노출되도록 만들기 때문에 캡슐화를 저해한다.
  - 객체의 내부 구현을 변경하면 퍼블릭 인터페이스도 함께 변경되고, 결국 객체에 의존하는 클라이언트로 변경의 영향이 전파 된다. (데이터 주도 설계)
- 역할을 이용하면 불필요한 중복 코드를 제거 할 수 있다.
  - item, vendor, vendor item 컬렉션 정보를 가져온다. > 컬렉션 정보를 가져온다
  - 역할을 수행하는 모든 객체들이 공유하는 상태와 행동의 기본구현이 존재: abstract class, 책임의 목록만 정의: interface


## 💡 느낀 점
- 역할을 이용하면 불필요한 중복 코드를 제거 할 수 있다.
  - item, vendor, vendor item 컬렉션 정보를 가져온다. > 컬렉션 정보를 가져온다
  - 역할을 수행하는 모든 객체들이 공유하는 상태와 행동의 기본구현이 존재: abstract class, 책임의 목록만 정의: interface
- inteface Collection
  - class NoneCollection implement Collection
  - abstract class DefaultCollection implement Collection
    - class ItemCollection extends DefaultCollection
  - 공통 적인 것과 아닌 것을 이렇게 분리 할 수 있음
- 역할에 의해 구체적인 조건 보다는 어떤 행동을 하는 상황이라는 것을 파악할 수 있게 된다.


## ❓ 궁금한 점
- 


## 🔗 참고 링크
-

