# 모듈
----- 
- 모듈이란 크기와 상관 없이 클래스나 패키지, 라이브러리와 같이 프로그램을 구성하는 임의의 요소
###### 모듈의 목적
- 실행중에 재대로 동작 한다.
- 변경을 위해 존재 한다.  간단한 작업만으로도 변경이 가능 해야 한다.
- 코드를 읽는 사람과 의사소통 하는 것. 모듈은 특별한 훈련 없이도 개발자가 쉽게 읽고 이해 할 수 있어야 한다.
# [[의존성]]
----
- 의존성은 변경에 대한 영향을 암시한다. 즉 의존성이란 말은 어떤 객체가 변경 될 때  그 객체에게 의존하는 다른 객체도 함께 변경 될 수도 있다.
- 객체 지향 설계는 의존하면서 협력하는 객체들의 공동체를 구축하는 것이다.
- 즉, 결합도를 낮추어 변경이 용이한 설계를 만들어야 한다.
- 결합도를 낮춘다는 것으 객체사이의 의존 관계를 낮춘다는것 이다.

# [[캡슐화]]와 [[응집도]]
----
- 개념적이나 물리적으로 객체 내부의 세부적이 사항을 감추는 것을 캡슐화라고 부른다.
- 캡슐화를 통해 객체 내보로의 접근을 제한하면 객체와 객체 사이의 결합도를 낮출 수 있다.
- 객체를 인터페이스와 구현으로 나누고 인터페이스만을 공개하는 것은 결합도를 낮추고 변경하기 쉬운 코드를 작성 하근 가장 기본적인 설계이다.
- 쉽고 유연한 설계를 얻기 위한 핵심은 객체 내부의 상태를 캡슐화하고 객체 간에 오직 메시지를 통해서만 상호 작용하도록 만드는 것이다.
- 밀접하게 연관된 작업만을 수행하고 연관성 없는 작업은 다른 객체에게 위임하는 객체를 가리켜 응집도가 높다고 한다.
- 즉, _**'자신의 데이터를 스스로 처리'**_ 하는 자율적인 객체를 만들면 결합도를  낮출 수 있을 뿐더러 응집도를 높일 수 있다.

# 절차지향과 객체지향
---- 
- 프로세스와 데이터를 별도의 모듈에 위치시키는 방식을 절자치향적 프로그래밍
- 절차 지향적 프로그래밍은 변경에 취약하다.(데이터가 변경되면 프로세스도 변경되어야 하기 때문)
- 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 하는 프로그래밍 방식을 객체지향 프로그래밍
- 자신의 문제를 스스로 처리해야 한다는 점에서 의존성을 줄일 수 있다.
- 훌륭한 객체지향 설계의 핵심은 캡슐화를 이용해 의존성을 적절히 관리 함으로써 객체사이의 결합도를 낮추는것

# 객체지향 설계
---- 
> 설계란 코드를 배치 하는 것이다.

좋은 설계란 ?  기능을 구현하는 동시에 쉽게 변경할 수 있는 코드를 짜야 한다.
# 책임
----
- 객체 지향의 설계에서는 각 객체에 책임이 적절하게 분배된다.
- 각 객체가 자신을 스스로 책임진다.
- 데이터와 프로세스를 하나의 단위로 통합해 놓는 방식
### 책임이란?
-  협력에 참여하기 위해 객체가 수행하는 행동을 책임이라고 부른다. 즉, 책임이란 객체에 의해 정의되는 응집도 있는 "행위의 집합" 이다, 객체가 '무엇을 알고 있는가' 와 '무엇을 할수 잇는가'로 구성된다.
###### 하는것
- 객체를 생성하거나 계산을 수행하는 등의 스스로 하는것
- 다른 객체의 행동을 시작시키는 것
- 다른 객체의 활동을 제어하고 조절하는 것
###### 아는것
- 사적인 정보에 관해 아는 것
- 관련된 객체에 관해 아는것
- 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것

##### 책임주도 설계
책임을 찾고 책임을 수행할 적절한 객체를 찾아 책임을 할당하는 방식으로 협력을 설계하는 방법

##### 책임주도 설계 방법의 과정
- 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악 한다.
- 시스템 책임을 더 작은 책임으로 분할한다.
- 분할된 책임을 수행할 수 있는 적적한 객체 또는 역할을 찾아 책임을 할당한다.
- 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
- 해당 객체 또는 역할에게 책임을 할당함으로써두 객체가 협력하게 한다.

협력은 객체를 설계하기 위한 구체적인 문맥을 제공한다. 협력이 책임을 이끌어내고 책임이 협력에 참여할 객체를 결정한다.
##### 메시지가 객체를 결정한다.
객체에게 책임을 할당하는 데 필요한 메시지를 먼저 식별하고 메시지를 처리할 객체를 나중에 선택. 즉 ,객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택
메시지가 객체를 선택하게 해야하는 중요한 이유 .
1. 객체가 최소한의 인터페이스를 가질수 있게 된다.
-> 필요한 메시지가 식별될 때까지 객체의 퍼브릭 인터페이스에 어떤 것도 추가하지 않기 때문에 객체는 애플리케이션에 크지도, 작지도 안흔 꼭 필요한 크기의 인터페이스를 가질 수 있다.
2. 객체는 충분히 추상적인 인터페이스를 가질수 있게 된다.
-> 객체의 인터페이스는 무엇을 하는지 표핸해야 하지만 어떻게 수행하는지를 노출해서는 안된다.
메시지는 외부의 객체가 요청하는 무언가를 의미하기 때문에 메시지를 먼저 식별하면 무엇을 수행할지에 초점을 마추는 인터페이스를 얻을 수 있다 .

### 행동이 상태를 결정한다. 

   
 
