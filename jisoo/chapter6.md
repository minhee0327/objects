---
book: 오브젝트
chapter: "챕터 6: 메시지와 인터페이스"
date: 2025-04-27
tags:
  - 책요약
  - 오브젝트/chapter-6
  - 오브젝트
---

# 📖 챕터 6: 메시지와 인터페이스


## 🧠 핵심 요약  
- 클래스는 하나의 구현도구 이다. 클래스가 아니라 객체를 지향해야한다. 
- 즉 객체를 수행하는 책임에 초점을 맞춰야 한다. 
- 책임은 객체가 수신할수 있는 메시지의 기반이 된다. 
- 어플리케이션은 클래스로 구성되지만, 메시지를 통해서 정의 된다. 
##### 협력과 메시지 
---
- 두 객체의 협력관계는 클라이언-서버 모델로 표현 될 수 있다. 
- 협력 안에서 메시지를 전송하는 객체를 클라이언트, 메시지를 수신하는 객체를 서버라고 부른다. 
- 객체는 협력에 참여하는 동안 클라이언트와 서버 역할을 동시에 수행 하는 것이 일반적. 
- 메시지 :객체들이 협력하기 위해 사용할 수 있는 유일한 의사소통 수단. 
- 메시지 전송 (메시지 패싱):  한객체가 다른 객체에게 도움을 요청 하는 것
- 메시지 전송자 : 메시지를 전송 하는 객체 
- 메시지 수신자 : 메시지를 수신 하는 객체
##### 메시지와 메서드
--- 
- 메서드 : 메시지를 수신 했을때 실제로 실행되는 함수 또는 프로시저 
- 코드 상에서 동일한 이름의 변수에게 동일한 메시지를 전송 하더라도 객체에 따라 실행 되는 메서드가 달라 질 수 있다. 
- 객체는 메시지와 메서드라느 두가지 서로 다른 개념을 실행 시점에 연결해야 하기 때문에 컴파일 시점의 의미가 달라질 수 있다.
- 실행 시점에 실행되는 코드는 메시지를 수신하는 객체의 타입에 따라서 달라진다. 
- 메시지 전송자와 메시지 수신자는 서로에 대한 상세한 정보를 알지 못한 채 단지 메시지라는 얇고 가는 끈을 통해 연결된다. 
##### 퍼블릭 인터페이스와 오퍼레이션 
--- 
- 객체가 의사소통을 위해 외부에 공개하는 메시지의 집합을 **퍼블릭 인터페이스** 라고 부른다. 
- 퍼블릭 인터페이스에 포함된 메시지를 **오퍼레이션** 이라고 부른다 
- 오퍼레이션은 구현 코드는 제외하고 단순히 메시지와 관련된 시그니처를 가리키는 경우가 대부분. 
- 오퍼레이션의 이름과 파라미터 목록을 합쳐 시그니처 라고 부른다. 일반 적으로 메시지를 수신하면 오퍼레이션의 시그니처와 동일한 메서드가 실행 된다. 
##### 인터페이스와 설계 품질 
----
- 퍼블릭 인터페이스의 품질에 영향을 미치는 원칙과 기법
###### 디미터 법칙 
---
- 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 ***==제한==*** 하라. 
- 디미터의 법칙을 따르기 위해서는 클래가 특정한 조건을 만족하는 대상에게만 메시지를 전송하도록 프로그래밍 해야 한다 . 
- C: 모든 클래스 
- M : C 에 구현된 모든 메서드 
- M에 의해 생성된 객체나  M이 호출하는 메서드에 의해 생성된 객체 전역 변수로 선언된 객체는 모두 M의 인자로 간주한다. 
- 메시지 전송 조건  
	- M의 인자로 전달된 클래스(c 자체를 포함)
	- C의 인스턴스 변수의 클래스 
- 좀더 풀어 쓴 메시지 전송 조건 
	- this 객체 
	- 메서드의 매개변수 
	- this의 속성
	- this의 속성인 컬렉션의 요소
	- 메서드 내에서 생성된 지역 객체 
- 디미터의 법칙은 객체가 자기 자신을 책임지는 자율 적인 존재여야 한다는 사실을 강조 
- 내부 구현을 묻는 코드보다 수신자에게 시키는 코드가 더좋은 코드이다. 
###### 묻지말고 시켜라 
--- 
- 디미터의 법칙은 묻지말고 시켜라 라는 스타일의 형태의 메시지를 장려한다. 
- 메시지 전송자는 메시지 수신자의 상태를 기반으로 결정을 내린후 메시지 수신자의 상태를 바꿔서는 안 된다. 
- 내부의 상태를 묻는 오퍼레이션을 인터페이스에 포함시키고 있는 지 확인해 보자. 
- 상태를 묻는 오퍼레이션에서 행동을 요청하는 오퍼레이션으로 대체하자 -> 의도를 드러내는 선택자.
- 하나의 구현을 가진 메시지의 이름을 일반화 하도록 도와주는 훈련방법 
	- 매우 다른 두번째 구현을 상상하고, 해당 메서드에 동일한 이름을 붙힌다고 상상해보자. 그러면 추상적인 이름을 얻을 수 있다. 
- 의도를 드러내는 인터페이스 -> 수행 방법에 관해서는 언급하지 말고 결과와 목정만을 포함하도록 클래스와 오퍼레이션의 이름을 부여하라. 이렇게 하면 클라이언트 개발자가 내부를 이해해야 할 필요성이 줄어든다. 
- 메서드를 명명하는 두가지 방법 
	- 메서드가 작업을 어떻게 수행하는지를 나타내도록 이름 짓는 방법 -> 이런 스타일은 좋지 않음 내부 구현 방법을 드러냄 P.188
	- 어떻게가 아니라 무엇을 하는지 드러내게 이름 짓는 방법 
##### 원칙의 함정 
--- 
- 디미터의 법칙과 묻지말고 시켜라 스타일은 절대적인 법칙은 아니다.
- 원칙이 현재 상황에 부합하지 않으면 무시하라.
- 원칙이 유용한지 아닌지를 판단하느 능력을 기르자.
- 자료구조는 묻는 수밖에없다. 객체는 내부구조를 숨겨야 하지만 자료구조 라면 당연히 내부를 노출해야 한다. 
##### 명령-쿼리 분리 원칙 
- 루틴 : 어떤 절차를 호출 가능하도록 이름을 부여한 기능 또는 모듈
- 프로시저: 정해진 절차에 따라 내부상태를 변경하는 루틴의 한 종류 
- 함수 : 어떤 절차에 따라 필요한 값을 반환하는 루틴의 한 종류 
- Command and Query 는 객체읜 인터페이스 층면에서 프로시저와 함수를 부르는 또 다른 이름. 
- Command 와 Query를 분리 하기 위해서는 다음 두 가지 규칙을 준수 해야함 
	- 객체의 상태를 변경하는 명령은 반환값을 가질 수 없다. 
	- 객체의 정보를 반환하는 쿼리는 상태를 변경할 수 없다. 
- 명령과 쿼리를 분리하면 부수효과를 제어하기 수월해진다. 
- 참조 투명성 
	- 어떠한 표현식 e가 있을때 모든 e를 e의 값으로 바꾸더라도 결과가 달라지지 않는 특성. 
- 불변성 
	- 어떠한 값이 변하지 않는 성질 
- 객체지향은 상태를 변경한다는 것이 기반에 깔려 있음 -> 이것은 부수효과를 가지고 있음 
- 명령-쿼리 분리 원칙을 사용하면 부수효과를 가지는 명령으로부터 부수효과를 가지지 안흔 쿼리를 명백하게 분리함으로써 제한적이나마 참조 투명성의 혜택을 누릴 수 있게 된다.




## 💡 인사이트 / 느낀 점  

## ❓ 질문 / 더 알아볼 것 
-  디미터의 법칙에서 내부 구조를 묻는 코드란 무엇일까?
- 

## 📌 관련 링크 또는 참고 메모 


