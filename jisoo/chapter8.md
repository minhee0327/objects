---
book: "오브젝트"
chapter: "챕터 8: 의존성 관리하기"
date: "2025-05-07"
tags: ["책요약", "오브젝트/chapter-8"]
---

# 📖 챕터 8: [[의존성]] 관리하기


## 🧠 핵심 요약  
#### [[의존성]] 
--- 
- 어떤 객체가 예정된 작업을 정상적으로 수행 하기 위해 다른 객체를 필요로 하는 경우 두 객체 사이에 의존성이 존재한다고 한다. 
- 의존성은 방향성이 있으며 단방향이다. 
- 함께 변경될수 있는 가능성을 의미하며 의존성은 전이 되기도 한다. 
- 직접의존성 : 한 요소가 다른 요소에 직접적으로 의존 
- 간접의존성 : 직접적인 의존 관계는 존재하지 않지만, 의존성 전이 의해서 영향이 전파 되는 경우 
###### 런타임 의존성 vs 컴파일 의존성
- 런타임 의존성 : 객체 사이의 의존성, 컴파일 의존성 : 클래스 사이의 의존성 
- 런타임 의존성과 컴파일 의존성은 다를 수 있음 (컴파일 시점에는 추상 클래스에 의존성이 있지만 런타임시엔 구현체에 의존성이 생김)
- 컴파일 타임 구조와 런타임 구조 사이의 거리가 멀면 멀수록 설계가 유연해지고 재상용 가능해진다. 
###### 컨텍스트 독립성 
- 클래스가 사용될 특정한 문맥에 대해 최소한의 가정만으로 이뤄져 있다면 다른 문맥에서 재사용하기 더 수월해진다. 이를 컨텍스트 독립성 이라 한다. 
- 자신이 사용될 컨택스트에 대한 구체정보를 최소한 만 알아야 한다. 
###### 의존성 해결
 - 컴파일타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는것 
 - 의존성 해결 방법 
	 - 객체를 생성하는 시점에 생성자를 통해 의존성 해결 (생성자 주입)
	 - 객체 생성후 setter 메서드를 통해 의존성 해결 (세터 주입): 의존성을 중간에 변경 할 수 있음. 하지만 의존 대상을 설정 하기 전까지는 객체의 상태가 불완전 할 수 있다. 
	 - 메서드 실행 시 인자를 이용해 의존성 해결 
#### 유연한 설계 
----
###### 의존성과 [[결합도]] 
- 의존성은 객체들의 협력을 가능하게 만드는 관점에서 바람직 한 것 
- 과한 의존성은 문제가 될수 있음 
- 바람직한 의존성은 재사용성과 관련이 있다. 의존성 때문에 재사용성이 제한 된다면 바람직하지 못한 의존성이다. 즉 바람직한 의존성은 다양한 환경에서 재상용 될 가능성을 열어두는 것 
- 느슨한 결합도, 약한 결합도 : 의존성이 바람직할 때
- 단단한 결합도, 강한 결합도 : 의존성이 바람직하지 못할 때 
###### 지식이 결합을 낳는다
- 추상화를 통해서 협력하는 대상에 대해 필요한 정보를 최대한 감출 수 있다. 
###### [[추상화]]에 의존하라 
- 추상화를 사용하면 현재 문제를 해결하는데 지식의 양을 줄임으로써 결합도를 느슨하게 유지 할 수 있다. 
- 지식의 양 순서 : 구체클래스 -> 추상 클래스 -> 인터페이스 
- 추상클래스는 협력하는 대상이 속하는 상속 계층을 알아야함 그래서 인터페이스가 더 지식의 양이적음 
- 인터페이스를 사용하자 
###### 명시적인 의존성 
숨겨진 의존성 
```java
public class Movie {
	...
	private DiscountPolicy discountPolicy;

	public Movie(String title, ....) {
		...
		this.discountPolicy = new AmountDiscountPolicy(...);
		// 결합도가 높아졌음  
	}
}
```

명시적인 의존성
```java
public class Movie {
	...
	private DiscountPolicy discountPolicy;

	public Movie(String title, ....,DiscountPolicy discountPolicy ) {
		...
		this.discountPolicy = discountPolicy;
		// 이부분이 명시적인 의존성 
	}
}
```
- 의존성이 명시적으로 퍼블릭 인터페이스에 노출 된다. 이를 명시적인 의존성이라고 부른다. 
- 의존성은 명시적으로 드러내야 한다. 구현에 숨기면 의존성 파악이 어려워진다. 
###### new 는 해롭다 
- new를 잘못 사용하면 클래스 사이의 결합도가 극단적으로 높아진다. 
- new는 구체클래스를 직접 기술 해야함 , new를 사용하는 클래스는 구체 클래스에 의존할 수 밖에 없음 
- new 를 사용하면 어떤인자를 이용해 생성자를 호출해야 되는지도 알아야된다. 이는 클라이언트가 알아야 하는 지식의 양이 늘어 나게 된다. 
- **해결 방법** 은 인스턴스를 생성하는 로직과 생성된 인스턴스를 사용하는 로직을 분리 하는 것 . 책에서는 인스턴스 생성을 클라이언트에 맡겼음. 
###### 가끔은 생성해도 무방하다
- 주로 협력하는 기본객체를 설정하는 경우가 여기에 속함 
- 구체 클래스에 의존하게 되더라도 클래스의 사용성이 더 중요하다면 결합도를 높이는 방향으로도 코드를 작성할 수 있다. 
- 종종 모든 결합도가 모이는 새로운 클래스를 추가함으로써 사용성과 유연성을 동시에 해결 할 수 있다 -> Factory
###### 표준 클래스에 대한 의존은 해롭지 않다. 
- 변경이 거의 없는 클래스라면 의존성이 문제가 되지 않는다. -> JDK

## 💡 인사이트 / 느낀 점  

## ❓ 질문 / 더 알아볼 것 
  - @qualifier는 어떤 구현체가 들어갈지 명시적으로 적어주는 데 구체 클래스에 의존 한것이 아닌가?

## 📌 관련 링크 또는 참고 메모 


