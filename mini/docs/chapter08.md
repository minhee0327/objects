# Chapter08 > 의존성 관리하기

## 📌 학습 내용 요약

1. 의존성 이해
   1. 변경과 의존성
      1. 어떤 객체가 다른 객체에 의존하면 그 객체가 변경될 때 영향을 받을 수 있다.
      2. 의존성이 발생하는 경로: 인스턴스 변수 / 메서드 매개변수 / 퍼블릭 인터페이스
   2. 의존성 전이
      1. A class → B class → C class 참조?  A→ C 참조 (의존성 전이)라고 무조건 하지는 않고, 캡슐화의 정도와 변경 전파의 방향에 따라서 결정이 된다. 
         의존성 전이란, 변경에 의해 영향이 널리 전파될 수도 있다는 경고일 뿐이다.
   3. 런타임 / 클래스 타임 의존성: 서로 달라야한다.
   4. 컨텍스트 독립성: 특정 문맥에 최소한의 가정으로만 이뤄져 있다면, 다른 문맥에서 재사용하기가 더 수월해진다. 
      1. 예를 들어 비율할인정책과 같이 비율할인이라는 문맥에 강하게 결합되어있으면, 다른 할인정책을 사용하기 어려울 수 있다.
   5. 의존성 해결하기: 컴파일타임 의존성을 적절한 런타임 의존성으로 교체하는 것.
      (객체 생성의 책임과 사용하는 책임을 분리)
      1. 객체를 생성하는 시점에 생성자를 통해 의존성해결
      2. 객체를 생성한 후 setter 메서드로 의존성 해결
      3. 메서드 실행인자를 이용해 의존성 해결
2. 유연한 설계
   1. 의존성과 결합도
      1. 의존성: 두 요소 사이의 관계 유무
      2. 결합도: 의존성의 정도
   2. 지식이 결합을 낳는다. → 많이 알 수록 결합도가 높아진다, 추상화하라
   3. 추상화에 의존. (구체 클래스 → 추상 클래스 → 인터페이스에 의존할수록 결합도가 낮아진다.)
   4. 명시적 의존성을 써라.
      1. 의존성 자체가 나쁜게 아니다. 숨어있는 의존성(=묵시적 의존성)이 문제이다.  예를 들어 생성자 내부에 직접 구체 클래스로 의존관계를 맺고 있다면, 찾아 내기가 어렵다.
   5. new 는 해롭다: 구체 클래스 명, 매개변수 등의 너무 많은 지식을 노출하게 된다.
   6. 가끔 생성해도 무방하다. (생성자 체이닝 / 메서드 체이닝같은 경우처럼 필요한 경우에 따라 생성하면, 사용성의 향상과 다양한 컨텍스트에서 사용가능한 여지를 제공한다.)
   7. 표준 class 의존은 해롭지 않다. (→ 의존하더라도 변경 확률이 적기 때문에 해롭지 않다.)
   8. 컨텍스트 확장: DiscountPolicy에 Amount, Percent, None의 예시만 계속 들었는데, 다중 할인에 대한 정책을 만들 때 단순히 클래스 하나 추가해서 if문을 사용하지 않고도 확장함
   9. 조합가능한 행동

## 💡 느낀 점

* 협력을 위해 필요한 의존성은 유지하고, 변경을 방해하는 의존성은 제거하는데 있다.

  

## ❓ 궁금한 점

- P255 > DayOfWeek 인스턴스에게 compareTo 메세지 전송이 아니고, equals 를 전송한다고 해야하는건가..? 



## 🔗 참고 링크