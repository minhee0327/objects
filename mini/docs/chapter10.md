# Chapter10> 상속과 코드 재사용

## 📌 학습 내용 요약
### 1. 상속과 중복 코드
- DRY 원칙: 중복코드는 변경을 방해한다. 코드 안에 중복이 존재 해서는 안된다.
- 예시
  - 요금제 계산을 위한  비슷한 내용이 들어있는 클래스 2개를 구현 (Phone / NightlyDiscountPhone)
  - 요구사항 변경에 따라 2벌을 고쳐야하는 상황 / 실수를 해서 한쪽만 고치는 경우가 발생하는 등의 번거로움
  - TypeCode를 써서 한 클래스에서 관리하도록 했더니 응집도는 낮아지고, 결합도가 높아짐
  - 대안으로 '상속'을 사용하여  중복코드를 제거했음.
  - 상속을 이용하니 자식클래스는 부모클래스의 구현방법에 대한 정확한 지식을 알고 있어야하는 문제가 생겨버림. (강하게 결합됨)
### 2. 취약한 기반 클래스 문제
- 취약한 기반 클래스 문제 발생:
    - 자식클래스의 작성자가 부모 클래스의 구현 방법에 대한 정확한 지식을 가지게 되는 문제
    - 강결합된 부모-자식 클래스, 캡슐화를 약하게 함
    - 객체지향의 기반은 캡슐화를 통한 변화의 통제인데, 장점을 희석시키게 된다.
- 불필요한 인터페이스 상속: (예1: Vector ← Stack)
    - vector를 상속받은 stack은 불필요하게 add(index, element)를 할 수 있음 LIFO 위반하게 될 수도 있는 여지가 생김
- 메서드 오버라이딩 오작용 문제 (예: HashSet <-> InstrumentedHashSet)
    - 부모클래스를 오버라이딩 하게 되면 부모클래스가 자신의 메서드를 사용하는 방법에 자식클래스가 결합될 수 있다.
- 부모 클래스와 자식 클래스의 동시 수정 문제
  -  클래스를 상속하면 결합도로 인해 자식 클래스와 부모클래스의 구현을 영원히 변경하지 않거나,   
  자식클래스와 부모클래스를 동시에 변경하거나 둘 중 하나를 선택할 수밖에 없다.
  
### 3. Phone 다시보기 
- 코드 중복을 제거하기 위해 상속을 도입할 때 따르는 2가지 원칙
  - 차이를 메서드로 추출하라
  - 중복 코드를 부모 클래스로 올려라
- 추상화가 핵심이다. 
  - 핵심 로직은 한곳에 모아놓고 조심스럽게 캡슐화해야한다. 공통적인 핵심로직은 최대한 추상화해야한다.

### 4. 차이에 의한 프로그래밍
- 기존 코드와 다른 부분만을 추가함으로써 애플리케이션의 기능을 확장하는 방법. 
- 상속이 코드 재사용 측면에서 강력한 도구이긴 하지만, 잘못사용하면 피해가 크다는 것을 경험했다. 
- 상속의 단점을 피하면서도 코드를 재사용하는 더 나은 방법인 '합성'에 대해 다음장에 나올 듯.

## 💡 느낀 점
- 코드 재사용을 위해, 상속을 사용하면 결합도가 높아지고, 부모에 대한 너무 많은 지식을 자식이 알게되어 변경에 대응하기 어려운 코드가 된다는 점을 배움.

## ❓ 궁금한 점
- PASS

## 🔗 참고 링크
