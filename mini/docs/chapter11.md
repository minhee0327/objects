# Chapter11 > 합성과 유연한 설계

## 📌 학습 내용 요약
- 상속과 합성 공동 목표: 재사용
- 상속/합성 차이점
  - 상속과 비교하여 합성은 안정성과 유연성이라는 장점을 제공한다.

    |                               | 상속                                     | 합성                                                 |
      |-------------------------------|----------------------------------------|----------------------------------------------------|
      | 재사용 방법                        | 부모클래스 - 자식클래스 연결해서 부모 클래스 코드 재사용       | 전체를 표현하는 객체가 부분을 표현하는 객체를 포함해서 부분 객체의 코드 재사용       |
      | 의존성                           | 컴파일타임에 해결 (정적)                         | 런타임에 해결 (동적)                                       |
      | 관계                            | is-a                                   | has-a                                              |
      | 사용방법                          | 자식클래스의 정의에 부모클래스를 붙이는 형식 (부모클래스를 물려받는) | 퍼블릭 인터페이스에 의존                                      |
      | 특징                            | 결합도가 높아짐 (부모-자식간)                      | 내부 구현이 변경되도 영향 최소화                                 |
      |                             | 화이트 박스 재사용 (부모의 구현이 자식에게 모두 노출)        | 블랙박스 재사용  (객체의 내부가 공개 되지 않고, 인터페이스만 공개)            |
      | 본질                            | 조합의 결과를 개별 클래스 안에 밀어 넣는 방법             | 조합을 구성하는 요소들을 개별 클래스로 구현한 후, `실행시점에 인스턴스를 조립하는 방법` |
      | 복잡도                           |                                        | 의존성 거리 멀수록 높아진다.                                   |
### 1. 상속을 합성으로 변경하기 (안정성)
- 10장에서 상속을 남용했을 경우의 문제점들을 합성으로 변경해봄. (안전성)
  - 불필요한 인터페이스 상속문제 (Stack, Properties 예시) -> 해결
  - 메서드 오버라이딩의 오작동문제 (InstrumentedHashSet - HashSet)   
    - 구현 결합도 제거 & 퍼블릭 인터페이스는 그대로 상속하여 해결하는 방법? => 인터페이스 사용
    - HashSet은 Set 인터페이스를 실체화한 구현체중 하나이면서, InstrumentedHashSet이 제공해야하는 모든 오퍼레이션이 들어있음.
  - 부모클래스와 자식클래스의 동시 수정문제
    - 합성으로 바꾸더라도 함께 수정해야하는 문제는 여전히 남아있음.
    - 그럼에도 변경의 파급효과를 최대한 (PersonalPlayList) 캡슐화 할 수 있음 
### 2. 상속으로 인한 조합의 폭발적인 증가
- 클래스 폭발 문제: 하나의 기능을 추가하기 위해 필요 이상으로 많은 수의 클래스를 추가해야하는 경우
- 컴파일타임에 결정된 부모 - 자식 클래스의 관계는 변경될 수 없기 때문에 자식 클래스와 부모클래스의   
다양한 조합이 필요한 상황에서 유일한 해결방법은 조합의 수만큼 새로운 클래스를 추가하는 것 뿐이다.
- 새로운 기능 추가 뿐만 아니라 수정할 때도 문제가 된다.

### 3. 합성 관계로 변경하기 (유연성)
-  컴파일타임 <-> 런타임의 의존성의 거리가 멀수록 설계가 유연해진다.
- 컴파일타임 의존성과 런타임 의존성의 거리가 멀 수록 설계의 복잡도가 상승하여 코드를 이해하기 어려워질 수는 있다.
- 대부분의 경우 단순한 설계가 답이지만, 변경에 따른 고통이 복잡성으로 인한 혼란을 넘어서고 있다면 유연성의 손을 들어주는게 현명한 판단일 확률이 높다.
- 합성을 사용하는 이유는 런타임에 객체 사이의 의존성을 자유롭게 변경할 수 있기 때문.
- 합성을 사용하여 요구사항 변경이 되는 경우 오직 하나의 클래스만 수정해도 된다.
- 객체 합성이 클래스 상속보다 더 좋은 방법이다. 
- 상속의 2가지 종류
  - 구현 상속 (-> 상속의 모든 단점은 구현상속에 국한된다. 13장에 자세히..)
  - 인터페이스 상속

### 4. 믹스인
- 합성처럼 유연하면서도 상속처럼 쉽게 코드를 재사용할 수 있는 방법.
- 객체를 생성할 때 코드 일부를 클래스 안에 섞어 넣어 재사용하는 기법을 가리키는 용어

## 💡 느낀 점
- 상속보다는 합성을 이용하도록 하자.
- 상속 중에서도 구현 상속을 피해야한다.


## ❓ 궁금한 점
- 합성처럼 유연하면서 상속처럽 쉽게 코드를 재사용할 수 있다면 믹스인 개념을 왜 자바에서는 도입하지 않았을까..?
  -  자바는 단일 상속이니깐 trait 처럼 여러개를 조합할 수 없어서..?
  - interface / 합성으로 충분해서..?

## 🔗 참고 링크
