# Chapter14 > 일관성 있는 협력

## 📌 학습 내용 요약   
### 1. 디자인패턴

#### 소프트웨어 패턴

- 하나의 실무 컨텍스트에서 유용하게 사용해왔고 다른 실무 컨텍스트에서도 유용할것이라고 예상되는 아이디어.
- 실무 지식을 효과적으로 요약하고 전달 (패턴은 경험의 산물)
- 지식전달, 커뮤니케이션의 수단으로 활용

#### 패턴 분류

- 아키텍처 패턴: 소프트웨어 전체 구조를 결정하기 위해 사용. 디자인패턴보다 상위
- 디자인패턴: 특정 정황내에서 일어난 설계문제를 해결, 중간 규모의 패턴
- 이디엄: 특정 프로그래밍 언어에 국한된 하위레벨의 패턴. 언어에 종속적
- 분석 패턴: 도메인 내의 개념적 문제를 해결하는데 초점을 맞춘다.

#### 패턴과 책임 주도 설계

- 패턴의 세부 내용이 중요한게 아니라, 특정한 상황에 적용할 수 있는 설계를 쉽고 빠르게 떠올릴 수 있다는 사실.
- 역할, 책임, 협력의 관점에서 유사점을 공유한다는 것이지, 특정 구현방식을 강제하는게 아니다.

#### 캡슐화와 디자인 패턴

- 어떤 디자인 패턴이 어떤 변경을 캡슐화하는지 이해하는 것이 중요하다.

#### 패턴은 출발점이다.

- 패턴입문자는 컨텍스트의 적절성은 무시한 채 패턴의 구조에만 초점을 맞춘다.
- 정당한 이유없이 사용된 모든 패턴은 설계를 복잡하게 만드는 장애물이다.
  복잡성의 가치가 단순성을 넘어설 때 정당화 되어야한다.
- 패턴이 적용된 최종 결과를 이해하는 것보다 패턴을 목표로 리펙터링하는 이유를 이해하는것이 훨씬 가치가 있다.

### 2. 프레임워크

#### 코드 재사용 대 설계 재사용

- 재사용관점에서 설계 재사용보다 더 좋은 방법은 코드 재사용이다.
- 구조적 측면: 추상 클래스나 인터페이스를 정의하고 인스턴스 사이의 상호작용을 통해 시스템 전체 혹은 일부를 구현해 놓은 재사용 가능한 설계
- 사용 목적: 코드와 설계의 재사용, 애플리케이션 개발자가 현재의 요구사항에 맞게 커스터마이징할 수 있는 애플리케이션의 골격.

#### 상위정책과 하위정책으로 패키지 분리하기

- 상위정책이 세부사항보다 더 다양한 상황에서 재사용 될 수 있어야한다.
- 변하는 것과 변하지 않는 것을 서로 분리해야한다.

#### 제어 역전 원리

- 전통적인 구조: 상위 정책이 구체적인 세부사항에 의존하는 전통적인 구조. 상위정책이 하부의 구체 코드를 호출한다. 라이브러리나 툴킷의 코드를 호출.
- 의존성 역전시킨 객체지향 구조: 프레임워크가 애플리케이션에 속하는 서브클래스의 메서드를 호출한다. 의존성을 역전시키면 제어 흐름의 주체역시 역전된다. 제어의 주체가 자신이 아닌 프레임워크로 넘어간 것.
- 프레임워크는 일반적인 해결책만 제공하고 애플리케이션에 따라 달라질 수 있는 특정한 동작은 비워둔다.

## 💡 느낀 점
  

## ❓ 궁금한 점
 

## 🔗 참고 링크
