# 부록 B, C

## 📌 학습 내용 요약 
### 부록 B: 타입계층의 구현  
- 타입: 개념의 분류, 인터페이스만을 정의하는 것으로 객체가 반응할 수 있는 오퍼레이션 집합 [(참조: 13장)](https://github.com/team-study-group/objects/blob/main/mini/docs/chapter13.md)
- 클래스: 객체의 구현을 정의한 것, 타입에 속하는 객체들을 구현하기 위한 구현 매커니즘.
- 타입과 타입계층을 구현하는 여러가지 방법
  - **클래스를 이용한 타입계층 구현**: 
    - 퍼블릭 인터페이스는 유지하면서 새로운 구현을 가진 객체를 추가할 수 있는 가장 간단한 방법
  - **인터페이스를 이용한 타입계층 구현**: 
    - 상속으로 인한 결합도 문제를 피하고 다중 상속이라는 구현 제약도 해결할 수 있는 방법.
    - 클래스가 아닌, 타입에 집중하라. (p582)
  - **추상클래스를 이용한 타입계층 구현**
    - 클래스 상속을 이용해 구현을 공유하면서도 결합도로 인한 부작용을 피하는 방법
    - 추상클래스를 이용한 타입계층 구현과, 구체클래스로 상속받는 방법과의 차이
      - 추상화의 정도: 추상메서드의 시그니처에만 의존한다.
      - 상속을 사용하는 의도: 자신의 인스턴스를 직접 사용하지 않고, 유일한 목적은 자식 클래스를 추가하는 것. 상속계층을 쉽게 확장하고 결합도로 인한 부작용을 방지하는 안정망을 제공한다.
      -  타입의 구현방법이 단한가지 이거나 단일 상속계층만으로도 타입계층을 구현하는데 무리가 없다면 클래스나 추상클래스를 이용해서 타입을 정의하는게 좋다. 그 외의 상황이라면 인터페이스를 이용하는 것을 고려하라. (p588)
  - **추상클래스와 인터페이스 결합**
    - 골격 구현 추상 클래스: 인터페이스를 이용해 타입을 정의하고 특정 상속 계층에 국한된 코드를 공유할 필요가 있을 경우에 추상클래스를 이용해서 코드 중복을 방지한다.
  - **덕 타이핑 사용하기**:
    - 덕 타이핑은 클래스나 인터페이스에 대한 의존성을 메시지에 대한 의존성으로 대체한다.
    - 자바같은 정적 타입언어는 지원하지 않음.   
    (정적타입 언어중 C++은 template을 써서 활용가능하지만 함수의 복사본을 만드는 단점이 있음.)
    - 동일한 시그니처의 메서드를 포함하면 같은 타입으로 판단. (루비같은 동적타입 언어)
    - 오류를 런타임으로 미루기 때문에 코드의 안정성을 약화시킬 수 있다.
  - **믹스인 이용한 타입계층 구현**: 
    - 예시: skala 의 `trait`
    - 자바8의 유사기능 디폴트 메서드
      - 추상클래스가 제공하는 코드 재사용성이라는 혜택을 누리면서 특정한 상속계층에 얽메이지 않는 인터페이스의 장점을 유지
      - 외부에 노출할 필요가 없는 메서드를 불필요하게 퍼블릭 인터페이스에 추가하는 결과를 낳게 됨. (인터페이스가 불필요하게 커짐)
      -  protected -> public (캡슐화 약화)
      - 디폴트메서드가 추가된 이유는 기존에 사용되고 있는 인터페이스에 새로운 오퍼레이션을 추가할 경우에 발생하는 하위 호환성 문제를 해결하기 위해서지, 추상클래스를 제거하기 위한게 아니다.

### 부록 C: 동적인 협력, 정적인 코드
-  동적모델: 객체 | 프로그램 실행구조를 표현하는 움직이는 모델 | 객체와 협력
- 정적모델: 프로그램 | 코드의 구조를 담는 고정된 모델 | 타입과 관계
- 프로그램 코드안에 담아지는 정적모델은 객체사이의 협력(동적모델)에 기반 해야 한다.
- 도메인 모델을 먼저 만들고 이를 기반으로 설계와 구현을 진행하라는 이야기를 볼 수 있는데, 도메인모델은 정적 모델이 아닌가?
- 도메인 모델과 구현
  - 도메인 모델이 클래스다이어그램처럼 정적인 형태로 표현돼야하는건 오해이다. 도메인에 대한 지식을 표현하고 코드의 구조에 대한 힌트를 제공한다면 어떤 형태로 표현하더라도 상관없다.
  - 도메인 모델은 행위(동작)를 담고 있다. 단순히 속성, 클래스 구조만 표현하는게 아니라, 도메인 개념의 책임과 행동을 같이 정의한 설계 모델.
  - 도메인 모델은 도메인 안에 존재하는 개념과 관계를 표현해야하지만, 최종 모습은 객체의 행동과 변경에 기반해야하며 코드의 구조를 반영해야한다.  
- 분석모델, 설계모델, 구현모델 사이에 어떠한 차이점도 존재하지 않는다. 행동과 변경이라는 요소에 영향을 받으며 전체 개발 주기 동안 동일한 모양을 지녀야한다.

## 💡 느낀 점 & 회고
- 앞으로 개발을 하면서 객체들의 역할, 책임, 협력 관계를 고려하고 행동과 변경에 기반한 설계를 하고있는가 를 고민하게 될 것 같습니다.
- 혼자 공부했다면 꼼꼼하게 다 못읽었을텐데, 같이 읽어서 다 볼 수 있었습니다 ㅎㅎ 😂
- 스터디할 때 직접 코드를 만들어서 적용해보면서, 논의한게 제일 좋았습니다 :)  


